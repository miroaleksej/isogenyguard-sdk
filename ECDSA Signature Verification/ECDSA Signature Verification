#!/usr/bin/env python3
"""
ECDSA Signature Verification and Topological Analysis System

This system verifies whether signatures from the Bitcoin network
belong to the theoretical (u_r, u_z) table structure as proven
in the topological analysis of ECDSA.

Key insight: "The R_x table doesn't lie — it reflects the true structure,
regardless of how the wallet tries to protect itself. All existing
signatures already lie within the (u_r, u_z) field."
"""

from fastecdsa.curve import secp256k1
from fastecdsa.point import Point
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import sys
import re

def parse_public_key(public_key_str):
    """
    Parse public key string into Point object on secp256k1 curve.
    
    Args:
        public_key_str: Hex string of public key (compressed or uncompressed)
        
    Returns:
        Point object representing the public key
    """
    # Remove any whitespace
    public_key_str = public_key_str.strip().replace(" ", "")
    
    # Handle compressed format (starts with 02 or 03)
    if public_key_str.startswith(('02', '03')):
        x = int(public_key_str[2:], 16)
        # Calculate y from x (using secp256k1 curve equation)
        alpha = (pow(x, 3, secp256k1.p) + 7) % secp256k1.p
        beta = pow(alpha, (secp256k1.p + 1) // 4, secp256k1.p)
        
        # Choose y based on prefix (02 = even y, 03 = odd y)
        if (public_key_str.startswith('02') and beta % 2 == 0) or \
           (public_key_str.startswith('03') and beta % 2 == 1):
            y = beta
        else:
            y = secp256k1.p - beta
            
        return Point(secp256k1, x, y)
    
    # Handle uncompressed format (starts with 04)
    elif public_key_str.startswith('04') and len(public_key_str) == 130:
        x = int(public_key_str[2:66], 16)
        y = int(public_key_str[66:], 16)
        return Point(secp256k1, x, y)
    
    raise ValueError("Invalid public key format. Must be compressed (02/03) or uncompressed (04) format.")

def signature_to_uz_ur(r, s, z, n):
    """
    Convert ECDSA signature (r, s, z) to (u_r, u_z) coordinates.
    
    Args:
        r, s, z: Signature components
        n: Order of the curve
        
    Returns:
        Tuple (u_r, u_z)
    """
    # Calculate modular inverse of s
    s_inv = pow(s, -1, n)
    
    # Compute u_r and u_z
    u_r = (r * s_inv) % n
    u_z = (z * s_inv) % n
    
    return u_r, u_z

def verify_signature_in_table(r, s, z, public_key):
    """
    Verify if the signature (r, s, z) belongs to the theoretical (u_r, u_z) table.
    
    Args:
        r, s, z: Signature components
        public_key: Public key as Point object
        
    Returns:
        Dictionary with verification results
    """
    n = secp256k1.q
    G = secp256k1.G
    
    # Step 1: Convert signature to (u_r, u_z)
    u_r, u_z = signature_to_uz_ur(r, s, z, n)
    
    # Step 2: Compute R = u_r * Q + u_z * G
    R = u_r * public_key + u_z * G
    
    # Step 3: Verify R_x equals r
    r_computed = R.x
    is_in_table = (r_computed == r)
    
    # Step 4: Standard ECDSA verification
    # Compute u1 = z * s^-1 and u2 = r * s^-1
    s_inv = pow(s, -1, n)
    u1 = (z * s_inv) % n
    u2 = (r * s_inv) % n
    
    # Compute R = u1 * G + u2 * public_key
    R_ecdsa = u1 * G + u2 * public_key
    
    # Verify R.x equals r
    ecda_valid = (R_ecdsa.x == r)
    
    return {
        "u_r": u_r,
        "u_z": u_z,
        "r_computed": r_computed,
        "is_in_table": is_in_table,
        "ecda_valid": ecda_valid,
        "point_R": R
    }

def generate_rx_table_sample(public_key, u_r, u_z, size=21):
    """
    Generate a small sample of the R_x table around the given (u_r, u_z).
    
    Args:
        public_key: Public key as Point object
        u_r, u_z: Center point for the sample
        size: Size of the sample (default 21x21)
        
    Returns:
        Matrix of R_x values
    """
    n = secp256k1.q
    G = secp256k1.G
    R_x_matrix = np.zeros((size, size), dtype=int)
    
    # Calculate the center of our sample
    center = size // 2
    
    # Generate values around the center point
    for i in range(size):
        for j in range(size):
            sample_u_r = (u_r - center + i) % n
            sample_u_z = (u_z - center + j) % n
            
            # Compute R = u_r * Q + u_z * G
            R = sample_u_r * public_key + sample_u_z * G
            
            # Get x-coordinate
            R_x_matrix[i, j] = R.x
    
    return R_x_matrix

def create_visualization(R_x_matrix, u_r, u_z, r, center_offset=10):
    """
    Create visualization of the R_x table sample with the signature point highlighted.
    
    Args:
        R_x_matrix: Matrix of R_x values
        u_r, u_z: Signature coordinates
        r: Signature r value
        center_offset: Offset for center point
        
    Returns:
        Path to saved visualization
    """
    size = R_x_matrix.shape[0]
    
    plt.figure(figsize=(12, 10))
    
    # Create custom colormap
    colors = [(0, 'darkblue'), (0.25, 'blue'), (0.5, 'cyan'), 
              (0.75, 'yellow'), (1, 'red')]
    cmap = LinearSegmentedColormap.from_list('ecdsa_cmap', colors)
    
    # Display the R_x table
    plt.imshow(R_x_matrix % secp256k1.q, cmap=cmap, aspect='auto', interpolation='nearest')
    plt.colorbar(label='R_x mod n')
    
    # Highlight the signature point
    center = size // 2
    plt.scatter([center], [center], color='lime', s=200, edgecolor='white', zorder=5,
                label=f'Signature point (u_r={u_r % secp256k1.q}, u_z={u_z % secp256k1.q})\nr={r}')
    
    # Add grid lines
    plt.grid(color='white', linestyle='-', linewidth=0.5, alpha=0.3)
    
    plt.title('ECDSA Signature Verification\n(R_x Table Sample Around Signature Point)', fontsize=14)
    plt.xlabel('u_z', fontsize=12)
    plt.ylabel('u_r', fontsize=12)
    plt.legend(loc='best', fontsize=10)
    
    plt.tight_layout()
    output_file = "signature_verification.png"
    plt.savefig(output_file, dpi=150, bbox_inches='tight')
    plt.close()
    
    return output_file

def main():
    print("="*80)
    print("ECDSA SIGNATURE VERIFICATION AND TOPOLOGICAL ANALYSIS SYSTEM")
    print("="*80)
    print("This system verifies whether Bitcoin network signatures belong to the theoretical")
    print("(u_r, u_z) table structure as proven in topological analysis of ECDSA.")
    print("\nKey insight: 'The R_x table doesn't lie — it reflects the true structure,")
    print("regardless of how the wallet tries to protect itself. All existing signatures")
    print("already lie within the (u_r, u_z) field.'")
    print("="*80)
    
    # Check if fastecdsa is available
    try:
        from fastecdsa import curve
    except ImportError:
        print("\nERROR: fastecdsa library is required.")
        print("Install it with: pip install fastecdsa")
        sys.exit(1)
    
    print("\nPlease enter the signature components and public key:")
    
    # Get user input
    try:
        r_hex = input("\nEnter r (hex): ").strip()
        r = int(r_hex, 16)
        
        s_hex = input("Enter s (hex): ").strip()
        s = int(s_hex, 16)
        
        z_hex = input("Enter z (hex, message hash): ").strip()
        z = int(z_hex, 16)
        
        public_key_str = input("Enter public key (hex): ").strip()
        public_key = parse_public_key(public_key_str)
        
        n = secp256k1.q
        
        # Validate inputs
        if r >= n or r <= 0:
            print(f"\nERROR: r must be between 1 and {n-1}")
            sys.exit(1)
        if s >= n or s <= 0:
            print(f"\nERROR: s must be between 1 and {n-1}")
            sys.exit(1)
        if z >= n or z < 0:
            print(f"\nERROR: z must be between 0 and {n-1}")
            sys.exit(1)
            
    except Exception as e:
        print(f"\nERROR: Invalid input - {str(e)}")
        sys.exit(1)
    
    print("\nVerifying signature in the theoretical (u_r, u_z) table...")
    
    # Verify the signature
    result = verify_signature_in_table(r, s, z, public_key)
    
    # Print results
    print("\n" + "="*50)
    print("VERIFICATION RESULTS")
    print("="*50)
    print(f"Signature (r, s, z):")
    print(f"  r = {hex(r)[2:]}")
    print(f"  s = {hex(s)[2:]}")
    print(f"  z = {hex(z)[2:]}")
    print(f"\n(u_r, u_z) coordinates:")
    print(f"  u_r = {result['u_r']} (hex: {hex(result['u_r'])[2:]})")
    print(f"  u_z = {result['u_z']} (hex: {hex(result['u_z'])[2:]})")
    
    print("\n" + "-"*50)
    print("THEORETICAL VERIFICATION")
    print("-"*50)
    
    if result['is_in_table']:
        print("✓ Signature belongs to the theoretical (u_r, u_z) table")
        print("  R_x(u_r, u_z) = r (as expected)")
    else:
        print("✗ Signature does NOT belong to the theoretical (u_r, u_z) table")
        print(f"  Computed R_x = {result['r_computed']}, but r = {r}")
    
    if result['ecda_valid']:
        print("\n✓ Signature is valid according to ECDSA equation")
    else:
        print("\n✗ Signature is NOT valid according to ECDSA equation")
    
    # Generate sample table and visualization
    print("\nGenerating visualization of the R_x table around signature point...")
    R_x_matrix = generate_rx_table_sample(public_key, result['u_r'], result['u_z'])
    viz_file = create_visualization(R_x_matrix, result['u_r'], result['u_z'], r)
    
    print(f"\nVisualization saved to: {viz_file}")
    print("\nKey insights from this verification:")
    print("1. The R_x table is fully determined by the public key alone")
    print("2. All valid signatures must correspond to a point in this table")
    print("3. This structure exists regardless of wallet protection methods")
    print("   (even RFC 6979 compliant implementations)")
    print("4. The topological structure (torus) with Betti numbers β₀=1, β₁=2, β₂=1")
    print("   is preserved in the table")
    
    print("\n" + "="*80)
    print("CONCLUSION")
    print("="*80)
    
    if result['is_in_table'] and result['ecda_valid']:
        print("This signature is valid and belongs to the theoretical (u_r, u_z) table,")
        print("confirming the fundamental principle: 'All existing signatures already")
        print("lie within the (u_r, u_z) field.'")
        print("\nThis demonstrates that the table R_x is not just data — it's a topological")
        print("structure (a 2-torus) that contains ALL possible signatures for the given key,")
        print("even those that have never been used on the network.")
    else:
        print("This signature appears to be invalid or malformed, which is extremely rare")
        print("in the Bitcoin network. Please double-check the input values.")
    
    print("\nAs proven in the research: 'For any public key Q = dG, the set of all possible")
    print("signatures is completely determined by the structure of the R_x(u_r, u_z) table,")
    print("and any real signature will correspond to some point in this table.'")

if __name__ == "__main__":
    main()
